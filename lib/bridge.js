// Generated by CoffeeScript 2.3.1
var BRIDGE_LOCAL, Binding, Bridge, BridgeBinding, BridgeConnection, Connection, EventEmitter, REGISTRY_HOST, REGISTRY_PORT, REGISTRY_PROTO, VERBOSE, argv, bridge, from_port, helpers, minimist, to_addr, zeromq,
  splice = [].splice;

zeromq = require('zeromq');

({EventEmitter} = require('events'));

({Binding, Connection, helpers} = require('somata'));

minimist = require('minimist');

// Parse command line arguments
argv = minimist(process.argv);

VERBOSE = process.env.SOMATA_VERBOSE || false;

REGISTRY_PROTO = process.env.SOMATA_REGISTRY_PROTO || 'tcp';

REGISTRY_HOST = process.env.SOMATA_REGISTRY_HOST || '127.0.0.1';

REGISTRY_PORT = process.env.SOMATA_REGISTRY_PORT || 8420;

from_port = argv.from || helpers.randomPort();

to_addr = helpers.parseAddress(argv.to);

if (!from_port && (to_addr == null)) {
  console.log("Usage: bridge --to [to host]:[to port] --from [from port]");
  console.log("At least one of --to or --from is required");
  process.exit();
}

BRIDGE_LOCAL = to_addr != null;

// Extend connection and binding to forward messages through bridge
BridgeConnection = class BridgeConnection extends Connection {
  handleMessage(message) {
    if (message.service != null) {
      return this.emit('forward', message);
    } else {
      return super.handleMessage(message);
    }
  }

};

BridgeBinding = (function() {
  class BridgeBinding extends Binding {
    handleMessage(client_id, message) {
      var ref;
      if ((ref = message.service) != null ? ref.match('bridge') : void 0) {
        return super.handleMessage();
      } else {
        if (message.kind === 'ping') {
          if (!this.forwarded_pings[message.id]) {
            this.forwarded_pings[message.id] = true;
            message.ping = 'hello';
          }
        }
        return this.emit('forward', client_id, message);
      }
    }

  };

  BridgeBinding.prototype.forwarded_pings = {};

  return BridgeBinding;

}).call(this);

Bridge = (function() {
  class Bridge extends EventEmitter {
    constructor() {
      super();
      if (to_addr != null) {
        this.createConnection();
      }
      this.createBinding();
      this.connectToRegistry();
    }

    // Send local registry info with remote bridge
    connectToRegistry() {
      this.registry_connection = new Connection({
        proto: this.registry_proto || REGISTRY_PROTO,
        host: this.registry_host || REGISTRY_HOST,
        port: this.registry_port || REGISTRY_PORT,
        service: {
          id: 'registry~b',
          name: 'registry'
        }
      });
      this.registry_connection.on('connect', this.connectedToRegistry.bind(this));
      this.registry_connection.subscribe('register', this.registeredService.bind(this));
      return this.registry_connection.subscribe('deregister', this.deregisteredService.bind(this));
    }

    connectedToBridge() {
      if (BRIDGE_LOCAL) {
        this.registry_connection.method('findServices', this.foundReverseLocalServices.bind(this));
        // Ask remote bridge for registry info
        return setTimeout(() => {
          return this.remoteBridgeMethod('findServices', this.foundForwardRemoteServices.bind(this));
        }, 1000);
      }
    }

    connectedToRegistry() {
      if (BRIDGE_LOCAL) {
        // Get local registry info and send to remote bridge
        return setTimeout(() => {
          return this.registry_connection.method('findServices', this.foundReverseLocalServices.bind(this));
        }, 1000);
      } else {
        return setTimeout(() => {
          this.registry_connection.method('findServices', this.foundForwardLocalServices.bind(this));
          return this.remoteBridgeMethod('findServices', this.foundReverseRemoteServices.bind(this));
        }, 1000);
      }
    }

    foundForwardLocalServices(err, forward_local_services) {
      var service, service_id, service_instances, service_name;
      for (service_name in forward_local_services) {
        service_instances = forward_local_services[service_name];
        for (service_id in service_instances) {
          service = service_instances[service_id];
          if (service.bridge == null) {
            this.forward_local_services[service_id] = service;
          } else {
            delete service_instances[service_id];
          }
        }
      }
      return this.remoteBridgeMethod('registerServices', forward_local_services, function(err, registered) {});
    }

    foundForwardRemoteServices(err, forward_remote_services) {
      var forward_remote_service_instances, service, service_id, service_instances, service_name;
      forward_remote_service_instances = [];
      for (service_name in forward_remote_services) {
        service_instances = forward_remote_services[service_name];
        for (service_id in service_instances) {
          service = service_instances[service_id];
          if (service.bridge == null) {
            service.port = from_port;
            service.bridge = 'forward';
            forward_remote_service_instances.push(service);
            this.forward_remote_services[service_id] = service;
          } else {
            helpers.log.w('[foundForwardRemoteServices] Ignore remote bridged', service);
          }
        }
      }
      return this.registry_connection.method('registerServices', forward_remote_service_instances, function() {
        return helpers.log.d('[foundForwardRemoteServices] Registered remote services with local bridge', Object.keys(forward_remote_services));
      });
    }

    foundReverseLocalServices(err, reverse_local_services) {
      var service, service_id, service_instances, service_name;
      for (service_name in reverse_local_services) {
        service_instances = reverse_local_services[service_name];
        for (service_id in service_instances) {
          service = service_instances[service_id];
          this.reverse_local_services[service_id] = service;
        }
      }
      return this.remoteBridgeMethod('registerServices', reverse_local_services, function(err, registered) {
        return helpers.log.d('[foundReverseLocalServices] Registered local services with remote bridge', Object.keys(reverse_local_services));
      });
    }

    foundReverseRemoteServices(err, reverse_remote_services) {
      var reverse_remote_service_instances, service, service_id, service_instances, service_name;
      reverse_remote_service_instances = [];
      for (service_name in reverse_remote_services) {
        service_instances = reverse_remote_services[service_name];
        for (service_id in service_instances) {
          service = service_instances[service_id];
          if (service.bridge != null) {
            continue;
          }
          this.reverse_remote_services[service_id] = service;
          service.port = from_port;
          service.bridge = 'reverse';
          reverse_remote_service_instances.push(service);
        }
      }
      return this.registry_connection.method('registerServices', reverse_remote_service_instances, function() {
        return helpers.log.d('[handleBridgeMethod.registerServices] Registered local bridge services with local remote registry', Object.keys(reverse_remote_services));
      });
    }

    remoteBridgeMethod(method, ...args) {
      var cb, handle_response, message, ref;
      ref = args, [...args] = ref, [cb] = splice.call(args, -1);
      if (cb != null) {
        handle_response = function(response) {
          return cb(response.error, response.response);
        };
      }
      message = {
        service: 'bridge',
        kind: 'method',
        method,
        args
      };
      if (BRIDGE_LOCAL) {
        return this.sendConnection(message, handle_response);
      } else {
        return this.sendBinding(this.bridged_connection_id, message, handle_response);
      }
    }

    registeredService(service) {
      if (service.bridge != null) {
        return;
      }
      if (BRIDGE_LOCAL) {
        service.bridge = 'reverse';
        this.reverse_local_services[service.id] = service;
      } else {
        service.bridge = 'forward';
        this.forward_local_services[service.id] = service;
      }
      return this.remoteBridgeMethod('registerService', service, function(err, registered) {
        return helpers.log.d('[registeredService] Registered local service with remote bridge', service.id);
      });
    }

    deregisteredService(service) {
      if (service.bridge != null) {
        return;
      }
      delete this.service_connections[service.id];
      if (BRIDGE_LOCAL) {
        delete this.reverse_local_services[service.id];
      } else {
        delete this.forward_local_services[service.id];
      }
      return this.remoteBridgeMethod('deregisterService', service, function(err, deregistered) {
        return helpers.log.d('[deregisteredService] Deregistered local service with remote bridge', service.id);
      });
    }

    // Binding accepts local connections, forwards through bridge connection to
    // remote bridge binding
    createBinding() {
      this.binding = new BridgeBinding({
        host: '0.0.0.0',
        port: from_port
      });
      this.binding.on('method', this.handleBridgeMethod.bind(this));
      return this.binding.on('forward', this.handleBindingForward.bind(this));
    }

    handleReverseBridge(message) {
      var instances, service, service_id, service_instances, service_name, services;
      if (message.method === 'registerServices') {
        services = message.args[0];
        instances = [];
        for (service_name in services) {
          service_instances = services[service_name];
          for (service_id in service_instances) {
            service = service_instances[service_id];
            if (service.bridge !== 'reverse') {
              service.port = from_port;
              service.bridge = 'forward';
              this.forward_remote_services[service.id] = service;
              instances.push(service);
            }
          }
        }
        return this.registry_connection.method('registerServices', instances, function() {
          return helpers.log.d('[handleReverseBridge] Registered local bridge service with local remote registry', service.id);
        });
      } else if (message.method === 'registerService') {
        service = message.args[0];
        service.port = from_port;
        service.bridge = 'forward';
        this.forward_remote_services[service.id] = service;
        return this.registry_connection.method('registerService', service, function() {
          return helpers.log.d('[handleReverseBridge] Registered local bridge service with local remote registry', service.id);
        });
      } else if (message.method === 'deregisterService') {
        service = message.args[0];
        delete this.service_connections[service.id];
        delete this.forward_remote_services[service.id];
        return this.registry_connection.method('deregisterService', service.name, service.id, function() {
          return helpers.log.d('[handleReverseBridge] Deregistered local bridge service with local remote registry', service.id);
        });
      }
    }

    handleBridgeMethod(connection_id, message) {
      var reverse_remote_service_instances, reverse_remote_services, service, service_id, service_instances, service_name;
      this.bridged_connection_id = connection_id;
      // Local bridge finding remote services
      if (message.method === 'findServices') {
        return this.registry_connection.method('findServices', (err, forward_local_services) => {
          var service, service_id, service_instances, service_name;
          for (service_name in forward_local_services) {
            service_instances = forward_local_services[service_name];
            for (service_id in service_instances) {
              service = service_instances[service_id];
              if (service.bridge == null) {
                this.forward_local_services[service_id] = service;
              } else {
                delete service_instances[service_id];
              }
            }
          }
          return this.sendBinding(this.bridged_connection_id, {
            id: message.id,
            kind: 'response',
            response: forward_local_services
          });
        });
      // Local bridge sending local services
      } else if (message.method === 'registerServices') {
        reverse_remote_services = message.args[0];
        reverse_remote_service_instances = [];
        for (service_name in reverse_remote_services) {
          service_instances = reverse_remote_services[service_name];
          for (service_id in service_instances) {
            service = service_instances[service_id];
            if (service.bridge != null) {
              continue;
            }
            this.reverse_remote_services[service_id] = service;
            service.port = from_port;
            service.bridge = 'reverse';
            reverse_remote_service_instances.push(service);
          }
        }
        return this.registry_connection.method('registerServices', reverse_remote_service_instances, function() {
          return helpers.log.d('[handleBridgeMethod.registerServices] Registered local bridge services with local remote registry', Object.keys(reverse_remote_services));
        });
      } else if (message.method === 'registerService') {
        service = message.args[0];
        helpers.log.d('[handleBridgeMethod.registerService]', service);
        if (service.bridge !== 'reverse') {
          return;
        }
        service.port = from_port;
        this.reverse_remote_services[service.id] = service;
        return this.registry_connection.method('registerService', service, function() {
          return helpers.log.d('[handleBridgeMethod.registerService] Registered local bridge service with local remote registry', service.id);
        });
      } else if (message.method === 'deregisterService') {
        service = message.args[0];
        delete this.service_connections[service.id];
        delete this.reverse_remote_services[service.id];
        return this.registry_connection.method('deregisterService', service.name, service.id, function() {
          return helpers.log.d('[handleBridgeMethod.deregisterService] Deregistered local bridge service with local remote registry', service.id);
        });
      }
    }

    // Reverse method call from remote connection to local service
    handleBindingForward(connection_id, message) {
      var connection;
      if (this.forward_local_services[message.service] != null) {
        if (connection = this.getServiceConnection(message.service)) {
          this.service_connection_cbs[message.id] = (response) => {
            if (this.reverse_local_services[message.service] != null) {

            } else {
              // @sendBinding connection_id, response
              return this.sendBinding(connection_id, response);
            }
          };
          return connection.send(JSON.stringify(message));
        } else {
          return helpers.log.e(`[handleBindingForward] Couldn't find local service ${message.service}`);
        }
      } else if (this.forward_remote_services[message.service] != null) {
        return this.sendConnection(message, (response_message) => {
          return this.sendBinding(connection_id, response_message);
        });
      } else if (this.reverse_remote_services[message.service] != null) {
        return this.sendBinding(this.bridged_connection_id, message, (response_message) => {
          return this.sendBinding(connection_id, response_message);
        });
      } else {
        return helpers.log.e('[handleBindingForward] Not handling', message);
      }
    }

    onBindingMessage(connection_id, message_json) {
      var cb, message;
      // TODO: There will be multiple connections to a binding, need
      // connection id per incoming messages for penidng callbacks
      message = JSON.parse(message_json.toString());
      if (VERBOSE) {
        helpers.log.i(`[binding.on message] <${connection_id}>`, message);
      }
      if (cb = this.binding_cbs[message.id]) {
        return cb(message);
      } else {
        return this.forwardBindingMessageToConnection(connection_id, message);
      }
    }

    // Outgoing connection to remote bridge, forwards messages and accepts
    // messages from remote binding to forward back through bridge binding to
    // local connection
    createConnection() {
      this.connection = new BridgeConnection({
        host: to_addr.host,
        port: to_addr.port,
        service: {
          id: 'bridge~c',
          name: 'bridge'
        }
      });
      this.connection.on('connect', this.connectedToBridge.bind(this));
      return this.connection.on('forward', this.onConnectionMessage.bind(this));
    }

    createServiceConnection(service) {
      var connection_socket;
      connection_socket = zeromq.socket('dealer');
      connection_socket.identity = helpers.randomString();
      connection_socket.connect(helpers.makeAddress('tcp', service.host, service.port));
      // Forward messages from remote binding to own binding to local connection
      connection_socket.on('message', this.onServiceConnectionMessage.bind(this));
      this.service_connections[service.id] = connection_socket;
      return connection_socket;
    }

    getServiceConnection(service_id) {
      var connection, service;
      if (connection = this.service_connections[service_id]) {
        return connection;
      } else {
        if (BRIDGE_LOCAL) {
          if (service = this.reverse_local_services[service_id]) {
            return this.createServiceConnection(service);
          }
        } else {
          if (service = this.forward_local_services[service_id]) {
            return this.createServiceConnection(service);
          }
        }
      }
    }

    onServiceConnectionMessage(message_json) {
      var cb, message;
      message_json = message_json.toString();
      message = JSON.parse(message_json);
      if (VERBOSE) {
        helpers.log.i("[service connection.on message]", message);
      }
      if (cb = this.service_connection_cbs[message.id]) {
        return cb(message);
      }
    }

    onConnectionMessage(message) {
      var connection, ref;
      if (VERBOSE) {
        helpers.log.i("[connection.on message]", message);
      }
      if ((ref = message.service) != null ? ref.match(/^bridge/) : void 0) {
        return this.handleReverseBridge(message);
      // Forwarding to a specific service
      } else if (message.service != null) {
        if (connection = this.getServiceConnection(message.service)) {
          this.service_connection_cbs[message.id] = (response) => {
            return this.sendConnection(response);
          };
          return connection.send(JSON.stringify(message));
        } else {
          return helpers.log.e(`[connection.on message] Couldn't find service for ${message.service}`);
        }
      } else {
        return this.forwardConnectionMessageToBinding(message);
      }
    }

    // Sending messages and storing callbacks
    sendConnection(message, cb) {
      var message_json;
      if (VERBOSE) {
        helpers.log.d('[sendConnection]', message);
      }
      message.id || (message.id = helpers.randomString());
      message_json = JSON.stringify(message);
      return this.connection.send(message, cb);
    }

    sendBinding(connection_id, message, cb) {
      if (VERBOSE) {
        helpers.log.d(`[sendBinding] <${connection_id}>`, message);
      }
      message.id || (message.id = helpers.randomString());
      return this.binding.send(connection_id, message, cb);
    }

    forwardBindingMessageToConnection(connection_id, message) {
      if (VERBOSE) {
        helpers.log.d(`[forwardBindingMessageToConnection] <${connection_id}>`, message);
      }
      return this.sendConnection(message, (response_message) => {
        return this.sendBinding(this.bridged_connection_id, response_message);
      });
    }

    forwardConnectionMessageToBinding(message) {
      if (this.bridged_connection_id != null) {
        if (VERBOSE) {
          helpers.log.d(`[forwardConnectionMessageToBinding] -> <${this.bridged_connection_id}>`);
        }
        return setTimeout(() => {
          return this.sendBinding(this.bridged_connection_id, message, (response_message) => {
            return this.sendConnection(response_message);
          });
        }, 500);
      } else {
        if (VERBOSE) {
          return helpers.log.e('[forwardConnectionMessageToBinding] no bridged_connection_id');
        }
      }
    }

  };

  Bridge.prototype.service_connections = {};

  Bridge.prototype.service_connection_cbs = {};

  Bridge.prototype.forward_local_services = {};

  Bridge.prototype.reverse_local_services = {};

  Bridge.prototype.forward_remote_services = {};

  Bridge.prototype.reverse_remote_services = {};

  return Bridge;

}).call(this);

bridge = new Bridge;
